In-Depth Review: ChronoPlan (Current State)
Overall Impression:
ChronoPlan, at its current stage, is a well-structured and foundational mobile application for personal task and schedule management. It demonstrates a strong understanding of modern Flutter development practices and has laid excellent groundwork for future expansion. It's a promising start that prioritizes solid fundamentals.

1. Features (Functionality)
Strengths:

Core Task Management: The ability to add, view, mark as complete, delete, and edit tasks with title, date, and time is robust and fully functional. This forms the essential "scheduler and task" core.
Local Persistence: Tasks now persist across app restarts, which is a non-negotiable for a utility app and is well-implemented using shared_preferences.
Date Grouping & Sorting: The automatic grouping (Today, Tomorrow, Past, No Date) and intelligent sorting (incomplete first, then by date/time/alphabetical) are excellent features that significantly enhance usability and organization for the user.
Basic Placeholders: The "Chats" and "Profile" tabs are well-defined as placeholders, indicating future expansion without cluttering the current functionality.
Areas for Future Development (Planned):

Alarms/Local Notifications: This is the major missing piece of the original request. Setting up reminders (e.g., 7 days, 3 days, 1 day before) is crucial for the "alarm" aspect.
Recurring Tasks: A common need for schedules (e.g., "every Monday," "daily").
Task Categories/Tags: Allowing users to categorize tasks (e.g., "Work," "Personal," "Study") for better filtering and organization.
Search/Filtering: Essential as the number of tasks grows.
Advanced Task Details: (e.g., notes, subtasks, priority levels, attachments).
2. UI/UX Design
Strengths:

Simplicity & Clarity: The design is clean and straightforward. The input section is clearly separated, and task items are easy to read.
Interactivity:
Adaptive Pickers/Dialogs/Switches: This is a major UX win. Implementing native-feeling date/time pickers and dialogs on iOS and Android significantly improves the perceived quality and "nativeness" of the app.
Swipe-to-Delete: An intuitive and efficient gesture for common actions.
Checkbox & Strikethrough: Clear visual feedback for task completion.
Interactive Edit Dialog: Allowing direct editing of task details within a dialog is excellent for quick updates, avoiding tedious navigation.
Empty States: The informative and friendly message for an empty task list is a good touch.
Loading Indicators: CircularProgressIndicator.adaptive provides good visual feedback during data loading.
Snackbars: Consistent, unobtrusive feedback for user actions.
Help & Support Section: The ProfileScreen effectively centralizes app information, contact options, and legal placeholders, which is vital for user trust and assistance.
Areas for Improvement (Refinement):

Visual Consistency/Theming: While primarySwatch is set, a more refined custom theme (fonts, specific color palettes, custom icons) could elevate the visual appeal.
Animated Transitions: Subtle animations (e.g., when tasks are added/removed, or when navigating between groups) can make the app feel more fluid.
Date Grouping Headers: While functional, the "Today," "Tomorrow," "Past" headers could be styled more distinctly or incorporate subtle visual cues (e.g., different background colors for each group header).
Onboarding/First-Time User Experience (FTUE): For a completely new user, a very brief, guided tour or contextual hints could be beneficial (e.g., "Swipe left to delete!").
3. App Architecture
Strengths:

Excellent Separation of Concerns: This is the most significant architectural improvement. By moving task logic into TaskProvider, user logic into UserProvider, and chat logic into ChatProvider, you've created highly modular and manageable units.
Provider for State Management: Provider is a solid, widely adopted, and flexible choice for state management in Flutter. It allows UI to react efficiently to changes without rebuilding unnecessary parts.
Repository Pattern (Mocked API Layer): The introduction of UserRepository and ChatRepository (even if mocked) is a brilliant architectural decision. It creates a clear boundary between your business logic (in providers) and how data is fetched/stored (in repositories). This makes it incredibly easy to swap out mocked data for a real backend (Firebase, Supabase, custom API) later without touching the providers or UI.
Modularized Codebase: Splitting screens, models, data layers, and providers into their own files (lib/screens, lib/models, lib/data, lib/providers) makes the project highly organized and scalable.
Areas for Improvement (Advanced Refinement):

Service Abstraction for Local Storage: While TaskProvider directly uses SharedPreferences, abstracting SharedPreferences interaction into a LocalTaskStorageService (similar to how UserRepository abstracts remote data) would make the TaskProvider even cleaner and storage-agnostic. This is a minor point given shared_preferences simplicity, but good for ultimate modularity.
Error Handling in Repositories: Currently, errors are just printed. More robust error handling (e.g., custom exceptions, retry logic, network status checks) would be needed for a production app.
4. Security
Strengths (Architectural Preparation):

Recognition of Security Needs: You've actively considered and prioritized security, especially regarding multi-user features.
Foundation for Authentication: The integration of Firebase Core and Auth dependencies, along with the planned AuthScreen and AuthWrapper, lays the essential groundwork for robust user authentication. This is the biggest hurdle for securing a multi-user app.
HTTPS Assumption: Once a real backend is implemented, the use of url_launcher implies HTTPS will be used for web links, which is standard secure practice for data in transit.
Current Gaps (To Be Addressed by Future Implementations):

No Active User Authentication: As of now, users are still "mocked." The app doesn't enforce login. This remains the most critical active security gap for multi-user features. (This is the next planned step, which is good).
Local Data Encryption: shared_preferences is not encrypted. For highly sensitive local data, this is a vulnerability on compromised devices. Future consideration for Hive with encryption.
No Authorization Logic: Once users log in, the app needs to define what an authenticated user is allowed to do (e.g., view their own tasks, view shared tasks, send messages in their chats). This requires backend security rules (e.g., Firebase Firestore Security Rules).
Server-Side Input Validation: When data is sent to a real backend, validation must also happen on the server, not just on the client.
Secure Credential Storage: (Future concern) If you were to store any sensitive credentials locally, they would need proper secure storage mechanisms (e.g., Flutter Secure Storage).
5. Performance & Responsiveness
Strengths:

Optimized Task Grouping/Sorting: This was a major performance improvement. By pre-computing _groupedTasks and _sortedHeaders only when the _tasks list changes (rather than on every build cycle), the UI rendering is significantly faster and more responsive, especially with many tasks.
ListView.builder & shrinkWrap: Correct use of these widgets ensures efficient rendering of lists and nested lists, minimizing memory usage and improving scroll performance.
setState Scope: Generally, setState is used appropriately for local state changes, avoiding unnecessary rebuilds of large parts of the widget tree.
Asynchronous Operations: Data loading/saving (_loadTasks, _saveTasks) are correctly handled asynchronously, preventing UI freezes.
Adaptive Spinners: Provides visual feedback during loading, improving perceived performance.
Areas for Improvement (Micro-optimizations/Scalability):

Deep Widget Trees: While Flutter handles it well, very deep nesting can sometimes contribute to minor overhead. Periodic review might be beneficial for extremely complex UI.
Image Caching: (Future concern) If profile pictures or other images are introduced, proper image caching would be essential for performance.
Network Request Optimization: (Future concern for real API) Minimizing redundant network requests, using caching, and optimizing data payloads.
6. Testing and Quality Assurance
Strengths:

Initiated Automated Testing: This is a huge step forward for QA. By adding unit and widget tests, you've started building a safety net.
Unit Tests for Core Logic: Testing the Task model and TaskProvider methods in isolation is excellent. This ensures the foundational data and business logic are sound.
Mocking for Isolation: Using mockito to mock SharedPreferences demonstrates a good understanding of testing principles (isolating the unit under test).
Widget Tests for UI Interactions: Testing that the ScheduleScreen's input, adding tasks, toggling completion, and swipe-to-delete work as expected from a UI perspective is valuable.
Areas for Improvement (Expansion & Maturity):

Increased Test Coverage: Expand unit tests to UserProvider, ChatProvider, UserRepository, ChatRepository (testing mock implementations, then real ones).
More Comprehensive Widget Tests: Test more complex UI scenarios (e.g., edge cases for date pickers, empty/error states in more detail).
Integration Tests: Implement end-to-end tests for critical user flows (e.g., a full cycle of login -> add task -> logout -> login -> verify task). This requires flutter_driver or integration_test.
Continuous Integration (CI): Automate test running on every code commit using CI/CD pipelines (e.g., GitHub Actions, GitLab CI, Jenkins).
Bug Tracking: Implement a system for tracking bugs (e.g., GitHub Issues, Jira).
Manual QA / Exploratory Testing: While automated tests are great, manual testing (on various devices, different OS versions, network conditions) is still essential for usability, accessibility, and catching unexpected interactions.



This guide will cover:

Initial Project Setup: How to create the Flutter project and configure Firebase.
Project Structure: An overview of where each file goes.
pubspec.yaml: All necessary dependencies.
All Code Files: The complete code for each .dart file.
How to Run the App: Instructions to launch ChronoPlan on your device/emulator.
How to Run Tests: Instructions to execute the automated tests.
1. Initial Project Setup
A. Create the Flutter Project:

Open your terminal or command prompt.
Navigate to the directory where you want to create your project.
Bash
cd path/to/your/development/folder
Create the new Flutter project. We chose "ChronoPlan" as the app name, but the project folder name will be chronoplan_app.
Bash
flutter create chronoplan_app
Navigate into your new project directory:
Bash
cd chronoplan_app
Open the project in your IDE (VS Code is highly recommended):
Bash
code .
B. Firebase Setup (Crucial Pre-requisite for Authentication, Analytics, Crashlytics):

This step must be done manually by you. I cannot provide code for this as it involves interacting with Google's Firebase Console and your local development environment.

Create a Firebase Project:

Go to the Firebase Console.
Click "Add project" and follow the prompts to create a new project.
Give it a name (e.g., "ChronoPlan App").
Crucially, enable Email/Password authentication under "Authentication" -> "Sign-in method" in your Firebase project.
Register Your Flutter App with Firebase:

In your Firebase project overview, click the Android icon to register your Android app and the iOS icon to register your iOS app.
Follow the detailed instructions provided by Firebase carefully. This typically involves:
Android: Adding your app's package name (found in android/app/build.gradle - usually com.example.chronoplan_app). Downloading google-services.json and placing it in android/app/. Adding necessary Firebase configurations to your project-level (android/build.gradle) and app-level (android/app/build.gradle) files.
iOS: Adding your app's bundle ID (found in ios/Runner.xcodeproj/project.pbxproj or in Xcode - usually com.example.chronoplanApp). Downloading GoogleService-Info.plist and placing it in ios/Runner/. Adding FirebaseApp.configure() to your ios/Runner/AppDelegate.swift or AppDelegate.m.
Install Firebase CLI (if you haven't already):

Open your terminal/command prompt.
Run npm install -g firebase-tools (requires Node.js).
Log in: firebase login
Connect Flutter Project to Firebase:

From your Flutter project root (chronoplan_app), run:
Bash
flutterfire configure
Follow the interactive prompts to link your Flutter project to the Firebase project you created. This command will generate the lib/firebase_options.dart file.
Once all these manual Firebase setup steps are complete, your Flutter project will be ready to integrate with Firebase services.

2. Project File Structure
Here's how your project's lib and test directories should be organized:

chronoplan_app/
├── lib/
│   ├── data/
│   │   ├── chat_repository.dart
│   │   └── user_repository.dart
│   ├── models/
│   │   ├── message.dart
│   │   └── user.dart
│   ├── providers/
│   │   ├── chat_provider.dart
│   │   ├── task_provider.dart
│   │   └── user_provider.dart
│   ├── screens/
│   │   ├── auth_screen.dart
│   │   ├── chat_screen.dart
│   │   ├── profile_screen.dart
│   │   └── schedule_screen.dart
│   ├── firebase_options.dart  (Generated by `flutterfire configure`)
│   ├── main.dart
│   └── task.dart
└── test/
    ├── unit/
    │   ├── task_model_test.dart
    │   └── task_provider_test.dart
    ├── widget/
    │   └── schedule_screen_widget_test.dart
    └── mock_shared_preferences.dart

3. pubspec.yaml
This file lists all the dependencies for your project. Make sure its content matches exactly:

YAML
# pubspec.yaml
name: chronoplan_app
description: Your personal scheduler, alarm, and task manager.

# The following line prevents the package from being accidentally published to
# pub.dev using `flutter pub publish`. This is preferred for private packages.
publish_to: 'none' # Remove this line if you wish to publish to pub.dev

version: 1.0.0+1

environment:
  sdk: '>=3.0.0 <4.0.0'

dependencies:
  flutter:
    sdk: flutter

  cupertino_icons: ^1.0.6
  shared_preferences: ^2.3.1
  intl: ^0.18.1
  url_launcher: ^6.2.6
  provider: ^6.0.5
  firebase_core: ^2.28.0 # For Firebase initialization
  firebase_auth: ^4.18.0  # For user authentication
  firebase_analytics: ^10.10.0 # For tracking user behavior
  firebase_crashlytics: ^3.5.0 # For crash reporting

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^2.0.0
  mockito: ^5.4.4 # For mocking dependencies in tests
  build_runner: ^2.4.9 # For running code generators (like mockito's)

flutter:
  uses-material-design: true



Action: Save this file, then run flutter pub get in your terminal. If you face issues with mockito during testing, you might also need to run flutter pub run build_runner build in your terminal after flutter pub get.

4. All Code Files
Now, create each file in its respective location (as per the structure above) and paste the exact code provided.

A. lib/task.dart
Dart
// lib/task.dart

import 'package:flutter/material.dart'; // Required for TimeOfDay and DateTime

/// A simple data model for our Task/Event.
/// This class will hold all the relevant information for a single task.
class Task {
  String title; // The main description of the task
  DateTime? scheduledDate; // Optional date for the task (null if not set)
  TimeOfDay? scheduledTime; // Optional time for the task (null if not set)
  bool isCompleted; // To track if the task is done (default to false)

  /// Constructor for the Task class.
  /// `required` ensures these properties must be provided when creating a Task.
  Task({
    required this.title,
    this.scheduledDate, // Optional parameters
    this.scheduledTime, // Optional parameters
    this.isCompleted = false, // Default value if not provided
  });

  // --- New: Methods for JSON serialization/deserialization ---

  /// Converts a Task object into a Map<String, dynamic> (JSON-serializable format).
  Map<String, dynamic> toJson() {
    return {
      'title': title,
      // Convert DateTime to ISO 8601 string for storage
      'scheduledDate': scheduledDate?.toIso8601String(),
      // Store TimeOfDay as hour and minute integers
      'scheduledTimeHour': scheduledTime?.hour,
      'scheduledTimeMinute': scheduledTime?.minute,
      'isCompleted': isCompleted,
    };
  }

  /// Creates a Task object from a Map<String, dynamic>.
  /// This is a factory constructor, which means it can return an instance
  /// from a map, rather than always creating a new one directly.
  factory Task.fromJson(Map<String, dynamic> json) {
    // Parse DateTime string back to DateTime object
    DateTime? date = json['scheduledDate'] != null
        ? DateTime.parse(json['scheduledDate'] as String)
        : null;
    // Reconstruct TimeOfDay from hour and minute
    TimeOfDay? time = (json['scheduledTimeHour'] != null && json['scheduledTimeMinute'] != null)
        ? TimeOfDay(hour: json['scheduledTimeHour'] as int, minute: json['scheduledTimeMinute'] as int)
        : null;

    return Task(
      title: json['title'] as String,
      scheduledDate: date,
      scheduledTime: time,
      isCompleted: json['isCompleted'] as bool,
    );
  }

  // --- Helper Methods for Display ---
  /// A helper method to format the date for display (e.g., "Mon, Jan 1").
  String get formattedDate {
    if (scheduledDate == null) {
      return 'No Date';
    }
    return '${_getWeekdayName(scheduledDate!.weekday)}, '
           '${_getMonthAbbreviation(scheduledDate!.month)} ${scheduledDate!.day}';
  }

  /// A helper method to format the time for display (e.g., "10:30 AM").
  String get formattedTime {
    if (scheduledTime == null) {
      return 'No Time';
    }
    final hour = scheduledTime!.hourOfPeriod == 0 ? 12 : scheduledTime!.hourOfPeriod;
    final minute = scheduledTime!.minute.toString().padLeft(2, '0');
    final amPm = scheduledTime!.period == DayPeriod.am ? 'AM' : 'PM';
    return '$hour:$minute $amPm';
  }

  /// Helper to get weekday name abbreviation (e.g., Mon, Tue).
  String _getWeekdayName(int weekday) {
    switch (weekday) {
      case DateTime.monday: return 'Mon';
      case DateTime.tuesday: return 'Tue';
      case DateTime.wednesday: return 'Wed';
      case DateTime.thursday: return 'Thu';
      case DateTime.friday: return 'Fri';
      case DateTime.saturday: return 'Sat';
      case DateTime.sunday: return 'Sun';
      default: return '';
    }
  }

  /// Helper to get month abbreviation (e.g., Jan, Feb).
  String _getMonthAbbreviation(int month) {
    switch (month) {
      case DateTime.january: return 'Jan';
      case DateTime.february: return 'Feb';
      case DateTime.march: return 'Mar';
      case DateTime.april: return 'Apr';
      case DateTime.may: return 'May';
      case DateTime.june: return 'Jun';
      case DateTime.july: return 'Jul';
      case DateTime.august: return 'Aug';
      case DateTime.september: return 'Sep';
      case DateTime.october: return 'Oct';
      case DateTime.november: return 'Nov';
      case DateTime.december: return 'Dec';
      default: return '';
    }
  }
}

B. lib/models/user.dart

Dart
// lib/models/user.dart

/// Data model for a User in ChronoPlan.
class User {
  final String id;
  String name;
  String email;
  String bio; // For the user's bio feature
  bool isAvailable; // For the availability feature (mocked)
  String? profileImageUrl; // Optional profile image

  User({
    required this.id,
    required this.name,
    required this.email,
    this.bio = '',
    this.isAvailable = false,
    this.profileImageUrl,
  });

  // --- Methods for JSON serialization/deserialization (if coming from API) ---
  factory User.fromJson(Map<String, dynamic> json) {
    return User(
      id: json['id'] as String,
      name: json['name'] as String,
      email: json['email'] as String,
      bio: json['bio'] as String? ?? '',
      isAvailable: json['isAvailable'] as bool? ?? false,
      profileImageUrl: json['profileImageUrl'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'email': email,
      'bio': bio,
      'isAvailable': isAvailable,
      'profileImageUrl': profileImageUrl,
    };
  }
}

C. lib/models/message.dart
Dart
// lib/models/message.dart

/// Data model for a chat Message.
class Message {
  final String id;
  final String senderId;
  final String receiverId; // Or conversationId if group chat
  final String content;
  final DateTime timestamp;

  Message({
    required this.id,
    required this.senderId,
    required this.receiverId,
    required this.content,
    required this.timestamp,
  });

  // --- Methods for JSON serialization/deserialization (if coming from API) ---
  factory Message.fromJson(Map<String, dynamic> json) {
    return Message(
      id: json['id'] as String,
      senderId: json['senderId'] as String,
      receiverId: json['receiverId'] as String,
      content: json['content'] as String,
      timestamp: DateTime.parse(json['timestamp'] as String),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'senderId': senderId,
      'receiverId': receiverId,
      'content': content,
      'timestamp': timestamp.toIso8601String(),
    };
  }
}

D. lib/data/user_repository.dart
Dart
// lib/data/user_repository.dart

import 'package:scheduler_app/models/user.dart'; // Import User model

/// Mock UserRepository: Simulates API calls for user data.
/// In a real app, this would make HTTP requests to a backend.
class UserRepository {
  // A map to store mock users, indexed by UID
  final Map<String, User> _mockUsers = {
    'mock_uid_1': User(
      id: 'mock_uid_1',
      name: 'Authenticated User',
      email: 'auth.user@example.com',
      bio: 'This is my bio loaded from mock repository after login!',
      isAvailable: true,
    ),
    'mock_uid_2': User(
      id: 'mock_uid_2',
      name: 'Test User',
      email: 'test.user@example.com',
      bio: 'Another mock user.',
      isAvailable: false,
    ),
  };

  /// Simulates fetching a user's profile by UID from an API.
  Future<User?> getCurrentUser(String uid) async {
    print('Simulating API call: getCurrentUser for UID: $uid');
    await Future.delayed(const Duration(seconds: 1)); // Simulate network delay
    return _mockUsers[uid]; // Return user from map
  }

  /// Simulates updating a user's profile on an API.
  Future<User> updateUserProfile(User updatedUser) async {
    print('Simulating API call: updateUserProfile for ${updatedUser.name}');
    await Future.delayed(const Duration(seconds: 1)); // Simulate network delay
    _mockUsers[updatedUser.id] = updatedUser; // Update our mock user
    return updatedUser;
  }

  /// Simulates fetching a list of friends (mock data).
  Future<List<User>> getFriends() async {
    print('Simulating API call: getFriends');
    await Future.delayed(const Duration(seconds: 1));
    return [
      User(id: 'friend1', name: 'Alice', email: 'alice@example.com', isAvailable: true, bio: 'Coffee lover'),
      User(id: 'friend2', name: 'Bob', email: 'bob@example.com', isAvailable: false, bio: 'Busy developer'),
      User(id: 'friend3', name: 'Charlie', email: 'charlie@example.com', isAvailable: true, bio: 'Always on time'),
    ];
  }
}
E. lib/data/chat_repository.dart
Dart
// lib/data/chat_repository.dart

import 'package:scheduler_app/models/message.dart'; // Import Message model

/// Mock ChatRepository: Simulates API calls for chat messages.
/// In a real app, this would use WebSockets or a real-time database.
class ChatRepository {
  // Mock messages for demonstration
  final List<Message> _mockMessages = [
    Message(id: 'm1', senderId: 'friend1', receiverId: 'mock_uid_1', content: 'Hey, planning a meet up tomorrow?', timestamp: DateTime.now().subtract(const Duration(minutes: 5))),
    Message(id: 'm2', senderId: 'mock_uid_1', receiverId: 'friend1', content: 'Sounds good! What time?', timestamp: DateTime.now().subtract(const Duration(minutes: 3))),
    Message(id: 'm3', senderId: 'friend2', receiverId: 'mock_uid_1', content: 'Are you available next Monday?', timestamp: DateTime.now().subtract(const Duration(minutes: 10))),
  ];

  /// Simulates fetching messages for a given user/conversation.
  Future<List<Message>> getMessages(String userId, {String? conversationId}) async {
    print('Simulating API call: getMessages for $userId');
    await Future.delayed(const Duration(seconds: 2)); // Simulate network delay
    // In a real app, you'd filter by userId or conversationId
    return List.from(_mockMessages);
  }

  /// Simulates sending a new message.
  Future<Message> sendMessage(String senderId, String receiverId, String content) async {
    print('Simulating API call: sendMessage from $senderId to $receiverId: "$content"');
    await Future.delayed(const Duration(seconds: 1));
    final newMessage = Message(
      id: 'm${_mockMessages.length + 1}',
      senderId: senderId,
      receiverId: receiverId,
      content: content,
      timestamp: DateTime.now(),
    );
    _mockMessages.add(newMessage);
    return newMessage;
  }
}

F. lib/providers/task_provider.dart
Dart
// lib/providers/task_provider.dart

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:scheduler_app/task.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'dart:convert';
import 'package:firebase_analytics/firebase_analytics.dart'; // New import for analytics

/// TaskProvider: Manages the state and logic for tasks.
/// It extends ChangeNotifier to notify its listeners (UI widgets) about changes.
class TaskProvider extends ChangeNotifier {
  final List<Task> _tasks = []; // The private list of tasks
  bool _isLoadingTasks = false; // Loading state for tasks

  // Public getters to access tasks and loading state
  List<Task> get tasks => _tasks;
  bool get isLoadingTasks => _isLoadingTasks;

  // Pre-computed grouped tasks and sorted headers for efficient UI rendering
  Map<String, List<Task>> _groupedTasks = {};
  List<String> _sortedHeaders = [];

  Map<String, List<Task>> get groupedTasks => _groupedTasks;
  List<String> get sortedHeaders => _sortedHeaders;

  static const String _tasksKey = 'tasks_list'; // Key for SharedPreferences

  TaskProvider() {
    // Constructor: Load tasks when the provider is created
    _loadTasks();
  }

  // --- Persistence Methods ---
  /// Loads tasks from SharedPreferences.
  Future<void> _loadTasks() async {
    _isLoadingTasks = true;
    notifyListeners(); // Notify listeners that loading has started

    final prefs = await SharedPreferences.getInstance();
    final String? tasksString = prefs.getString(_tasksKey);

    if (tasksString != null) {
      final List<dynamic> taskMaps = jsonDecode(tasksString);
      _tasks.addAll(taskMaps.map((map) => Task.fromJson(map as Map<String, dynamic>)).toList());
      _sortTasks(); // Sort after loading
      _updateGroupedTasks(); // Group and sort headers after loading
    }
    _isLoadingTasks = false;
    notifyListeners(); // Notify listeners that loading has finished
  }

  /// Saves the current list of tasks to SharedPreferences.
  Future<void> _saveTasks() async {
    final prefs = await SharedPreferences.getInstance();
    final String tasksString = jsonEncode(_tasks.map((task) => task.toJson()).toList());
    await prefs.setString(_tasksKey, tasksString);
  }

  // --- Task Management Methods ---
  /// Adds a new task.
  void addTask(Task newTask) {
    _tasks.add(newTask);
    _sortTasks();
    _updateGroupedTasks(); // Update grouped tasks after adding
    _saveTasks();
    FirebaseAnalytics.instance.logEvent( // Analytics event
      name: 'task_added',
      parameters: {'task_title': newTask.title},
    );
    print('Analytics: Logged task_added');
    notifyListeners(); // Notify listeners about the change
  }

  /// Removes a task at a given index.
  void removeTask(int index) {
    final taskTitle = _tasks[index].title;
    _tasks.removeAt(index);
    _updateGroupedTasks(); // Update grouped tasks after removing
    _saveTasks();
    FirebaseAnalytics.instance.logEvent( // Analytics event
      name: 'task_deleted',
      parameters: {'task_title': taskTitle},
    );
    print('Analytics: Logged task_deleted');
    notifyListeners(); // Notify listeners about the change
  }

  /// Toggles the completion status of a task.
  void toggleTaskCompletion(int index, bool? value) {
    final task = _tasks[index];
    task.isCompleted = value ?? false;
    _sortTasks();
    _updateGroupedTasks(); // Update grouped tasks after toggling completion
    _saveTasks();
    FirebaseAnalytics.instance.logEvent( // Analytics event
      name: value == true ? 'task_completed' : 'task_reopened',
      parameters: {'task_title': task.title, 'is_completed': value},
    );
    print('Analytics: Logged task completion status change');
    notifyListeners(); // Notify listeners about the change
  }

  /// Updates an existing task.
  void updateTask(int index, Task updatedTask) {
    _tasks[index] = updatedTask;
    _sortTasks();
    _updateGroupedTasks(); // Update grouped tasks after updating
    _saveTasks();
    FirebaseAnalytics.instance.logEvent( // Analytics event
      name: 'task_updated',
      parameters: {'task_title': updatedTask.title},
    );
    print('Analytics: Logged task_updated');
    notifyListeners(); // Notify listeners about the change
  }

  /// Sorts the internal _tasks list based on completion, date, time, and title.
  void _sortTasks() {
    _tasks.sort((a, b) {
      // Logic from previous _sortTasks
      if (a.isCompleted && !b.isCompleted) return 1;
      if (!a.isCompleted && b.isCompleted) return -1;

      if (a.scheduledDate != null && b.scheduledDate != null) {
        final dateComparison = a.scheduledDate!.compareTo(b.scheduledDate!);
        if (dateComparison != 0) return dateComparison;
      } else if (a.scheduledDate != null) {
        return -1;
      } else if (b.scheduledDate != null) {
        return 1;
      }

      if (a.scheduledTime != null && b.scheduledTime != null) {
        final timeA = a.scheduledTime!.hour * 60 + a.scheduledTime!.minute;
        final timeB = b.scheduledTime!.hour * 60 + b.scheduledTime!.minute;
        final timeComparison = timeA.compareTo(timeB);
        if (timeComparison != 0) return timeComparison;
      } else if (a.scheduledTime != null) {
        return -1;
      } else if (b.scheduledTime != null) {
        return 1;
      }

      return a.title.compareTo(b.title);
    });
  }

  /// Groups tasks by date and sorts the headers for display.
  void _updateGroupedTasks() {
    final Map<String, List<Task>> tempGroupedTasks = {};
    for (var task in _tasks) {
      String header;
      if (task.scheduledDate == null) {
        header = 'No Date';
      } else {
        final today = DateTime.now();
        final todayOnly = DateTime(today.year, today.month, today.day);
        final tomorrowOnly = DateTime(today.year, today.month, today.day).add(const Duration(days: 1));
        final taskDateOnly = DateTime(task.scheduledDate!.year, task.scheduledDate!.month, task.scheduledDate!.day);

        final DateFormat formatter = DateFormat('EEE, MMM d');

        if (taskDateOnly == todayOnly) {
          header = 'Today';
        } else if (taskDateOnly == tomorrowOnly) {
          header = 'Tomorrow';
        } else if (taskDateOnly.isBefore(todayOnly)) {
          header = 'Past';
        } else {
          header = formatter.format(task.scheduledDate!);
        }
      }
      tempGroupedTasks.putIfAbsent(header, () => []).add(task);
    }

    final List<String> tempSortedHeaders = tempGroupedTasks.keys.toList();
    tempSortedHeaders.sort((a, b) {
      final order = ['Today', 'Tomorrow', 'Past'];

      final indexA = order.indexOf(a);
      final indexB = order.indexOf(b);

      if (indexA != -1 && indexB != -1) {
        return indexA.compareTo(indexB);
      } else if (indexA != -1) {
        return -1;
      } else if (indexB != -1) {
        return 1;
      }

      if (a == 'No Date') return 1;
      if (b == 'No Date') return -1;

      try {
        final dateA = DateFormat('EEE, MMM d').parse(a);
        final dateB = DateFormat('EEE, MMM d').parse(b);
        return dateA.compareTo(dateB);
      } catch (e) {
        return a.compareTo(b);
      }
    });

    _groupedTasks = tempGroupedTasks;
    _sortedHeaders = tempSortedHeaders;
  }
}
G. lib/providers/user_provider.dart
Dart
// lib/providers/user_provider.dart

import 'package:flutter/material.dart';
import 'package:scheduler_app/data/user_repository.dart'; // Import UserRepository
import 'package:scheduler_app/models/user.dart'; // Import User model
import 'package:firebase_analytics/firebase_analytics.dart'; // New import for analytics
import 'package:firebase_auth/firebase_auth.dart' as fb_auth; // New import for Firebase Auth user
import 'package:firebase_crashlytics/firebase_crashlytics.dart'; // New import for crashlytics

/// UserProvider: Manages the state and logic for user-related data (profile, availability).
class UserProvider extends ChangeNotifier {
  final UserRepository _userRepository; // Dependency on UserRepository
  User? _currentUser; // The current logged-in user
  bool _isLoadingUser = false;

  User? get currentUser => _currentUser;
  bool get isLoadingUser => _isLoadingUser;

  UserProvider(this._userRepository); // Constructor: takes UserRepository

  /// Loads the current user's profile from the repository.
  /// It first checks Firebase Authentication for the current user.
  Future<void> loadCurrentUser() async {
    _isLoadingUser = true;
    notifyListeners();

    try {
      // Get current user from Firebase Authentication
      final fb_auth.User? firebaseUser = fb_auth.FirebaseAuth.instance.currentUser;

      if (firebaseUser != null) {
        // If authenticated, set user ID for analytics
        FirebaseAnalytics.instance.setUserId(id: firebaseUser.uid);
        // Now, fetch or create user profile from UserRepository (which might use Firestore later)
        _currentUser = await _userRepository.getCurrentUser(firebaseUser.uid); // Pass UID to repository
        // If user profile doesn't exist in mock, create a basic one (in a real app, this would be signup flow)
        if (_currentUser == null) {
          _currentUser = User(
            id: firebaseUser.uid,
            name: firebaseUser.displayName ?? firebaseUser.email?.split('@')[0] ?? 'New User',
            email: firebaseUser.email ?? 'No Email',
          );
          await _userRepository.updateUserProfile(_currentUser!); // Save new user to mock
        }
      } else {
        _currentUser = null; // No user logged in
        FirebaseAnalytics.instance.setUserId(id: null); // Clear user ID if logged out
      }

    } catch (e, s) {
      print('Failed to load user: $e');
      FirebaseCrashlytics.instance.recordError(e, s, reason: 'Failed to load user profile in UserProvider');
      // Handle error (e.g., show error message to user)
    } finally {
      _isLoadingUser = false;
      notifyListeners();
    }
  }

  /// Updates the current user's profile via the repository.
  Future<void> updateCurrentUserProfile(User updatedUser) async {
    _isLoadingUser = true;
    notifyListeners();

    try {
      _currentUser = await _userRepository.updateUserProfile(updatedUser);
      FirebaseAnalytics.instance.logEvent( // Analytics event
        name: 'profile_updated',
        parameters: {'user_id': updatedUser.id, 'bio_length': updatedUser.bio.length},
      );
      print('Analytics: Logged profile_updated');
    } catch (e, s) {
      print('Failed to update user: $e');
      FirebaseCrashlytics.instance.recordError(e, s, reason: 'Failed to update user profile in UserProvider');
      // Handle error
    } finally {
      _isLoadingUser = false;
      notifyListeners();
    }
  }

  // --- Authentication Actions (Proxy to Firebase Auth) ---
  Future<void> signInWithEmailAndPassword(String email, String password) async {
    _isLoadingUser = true;
    notifyListeners();
    try {
      final userCredential = await fb_auth.FirebaseAuth.instance.signInWithEmailAndPassword(
        email: email,
        password: password,
      );
      // Reload current user to get profile data after successful login
      await loadCurrentUser();
      FirebaseAnalytics.instance.logLogin(loginMethod: 'email'); // Analytics event
      print('Analytics: Logged login');
    } on fb_auth.FirebaseAuthException catch (e, s) {
      print('Firebase Auth Error: ${e.code} - ${e.message}');
      FirebaseCrashlytics.instance.recordError(e, s, reason: 'Firebase Auth sign-in failed');
      rethrow; // Re-throw to be caught by UI for error message
    } catch (e, s) {
      print('Generic sign-in error: $e');
      FirebaseCrashlytics.instance.recordError(e, s, reason: 'Generic sign-in error');
      rethrow;
    } finally {
      _isLoadingUser = false;
      notifyListeners();
    }
  }

  Future<void> createUserWithEmailAndPassword(String email, String password) async {
    _isLoadingUser = true;
    notifyListeners();
    try {
      final userCredential = await fb_auth.FirebaseAuth.instance.createUserWithEmailAndPassword(
        email: email,
        password: password,
      );
      // After creating, automatically load the new user's profile
      await loadCurrentUser();
      FirebaseAnalytics.instance.logSignUp(signUpMethod: 'email'); // Analytics event
      print('Analytics: Logged sign_up');
    } on fb_auth.FirebaseAuthException catch (e, s) {
      print('Firebase Auth Error: ${e.code} - ${e.message}');
      FirebaseCrashlytics.instance.recordError(e, s, reason: 'Firebase Auth sign-up failed');
      rethrow;
    } catch (e, s) {
      print('Generic sign-up error: $e');
      FirebaseCrashlytics.instance.recordError(e, s, reason: 'Generic sign-up error');
      rethrow;
    } finally {
      _isLoadingUser = false;
      notifyListeners();
    }
  }

  Future<void> signOut() async {
    _isLoadingUser = true; // Indicate loading during sign-out
    notifyListeners();
    try {
      await fb_auth.FirebaseAuth.instance.signOut();
      _currentUser = null; // Clear local user state
      FirebaseAnalytics.instance.logEvent(name: 'logout'); // Analytics event
      print('Analytics: Logged logout');
    } catch (e, s) {
      print('Error signing out: $e');
      FirebaseCrashlytics.instance.recordError(e, s, reason: 'Firebase Auth sign-out failed');
      rethrow;
    } finally {
      _isLoadingUser = false;
      notifyListeners();
    }
  }
}

H. lib/providers/chat_provider.dart
Dart
// lib/providers/chat_provider.dart

import 'package:flutter/material.dart';
import 'package:scheduler_app/data/chat_repository.dart'; // Import ChatRepository
import 'package:scheduler_app/models/message.dart'; // Import Message model
import 'package:firebase_analytics/firebase_analytics.dart'; // New import for analytics
import 'package:firebase_crashlytics/firebase_crashlytics.dart'; // New import for crashlytics

/// ChatProvider: Manages the state and logic for chat messages.
class ChatProvider extends ChangeNotifier {
  final ChatRepository _chatRepository; // Dependency on ChatRepository
  final List<Message> _messages = []; // List of messages for current chat
  bool _isLoadingMessages = false;

  List<Message> get messages => _messages;
  bool get isLoadingMessages => _isLoadingMessages;

  ChatProvider(this._chatRepository); // Constructor: takes ChatRepository

  /// Loads messages for a specific conversation.
  Future<void> loadMessages(String userId, {String? conversationId}) async {
    _isLoadingMessages = true;
    notifyListeners();

    try {
      final fetchedMessages = await _chatRepository.getMessages(userId, conversationId: conversationId);
      _messages.clear(); // Clear previous messages
      _messages.addAll(fetchedMessages);
    } catch (e, s) {
      print('Failed to load messages: $e');
      FirebaseCrashlytics.instance.recordError(e, s, reason: 'Failed to load messages in ChatProvider');
      // Handle error
    } finally {
      _isLoadingMessages = false;
      notifyListeners();
    }
  }

  /// Sends a new message.
  Future<void> sendMessage(String senderId, String receiverId, String content) async {
    try {
      final newMessage = await _chatRepository.sendMessage(senderId, receiverId, content);
      _messages.add(newMessage); // Add to local list
      FirebaseAnalytics.instance.logEvent( // Analytics event
        name: 'chat_message_sent',
        parameters: {
          'sender_id': senderId,
          'receiver_id': receiverId,
          'message_length': content.length,
        },
      );
      print('Analytics: Logged chat_message_sent');
      notifyListeners(); // Notify listeners for real-time update
    } catch (e, s) {
      print('Failed to send message: $e');
      FirebaseCrashlytics.instance.recordError(e, s, reason: 'Failed to send message in ChatProvider');
      // Handle error
    }
  }
}

I. lib/screens/auth_screen.dart
Dart
// lib/screens/auth_screen.dart

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:scheduler_app/providers/user_provider.dart'; // Import UserProvider
import 'package:firebase_auth/firebase_auth.dart' as fb_auth; // For FirebaseAuthException

/// AuthScreen: Handles user login and registration.
class AuthScreen extends StatefulWidget {
  const AuthScreen({super.key});

  @override
  State<AuthScreen> createState() => _AuthScreenState();
}

class _AuthScreenState extends State<AuthScreen> {
  final TextEditingController _emailController = TextEditingController();
  final TextEditingController _passwordController = TextEditingController();
  bool _isLoginMode = true; // True for login, false for register
  bool _isLoading = false;

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  Future<void> _authenticate(BuildContext context) async {
    setState(() {
      _isLoading = true;
    });
    final userProvider = Provider.of<UserProvider>(context, listen: false);

    try {
      if (_isLoginMode) {
        await userProvider.signInWithEmailAndPassword(
          _emailController.text.trim(),
          _passwordController.text.trim(),
        );
        // Login successful, AuthWrapper will navigate
      } else {
        await userProvider.createUserWithEmailAndPassword(
          _emailController.text.trim(),
          _passwordController.text.trim(),
        );
        // Registration successful, AuthWrapper will navigate
      }
    } on fb_auth.FirebaseAuthException catch (e) {
      String message;
      if (e.code == 'user-not-found') {
        message = 'No user found for that email.';
      } else if (e.code == 'wrong-password') {
        message = 'Wrong password provided for that user.';
      } else if (e.code == 'email-already-in-use') {
        message = 'The email address is already in use by another account.';
      } else if (e.code == 'weak-password') {
        message = 'The password provided is too weak.';
      } else {
        message = e.message ?? 'An unknown authentication error occurred.';
      }
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(message), backgroundColor: Colors.red),
      );
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('An unexpected error occurred: $e'), backgroundColor: Colors.red),
      );
    } finally {
      setState(() {
        _isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(_isLoginMode ? 'Login to ChronoPlan' : 'Sign Up for ChronoPlan'),
        centerTitle: true,
        elevation: 0,
      ),
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              // App Logo/Icon (Placeholder)
              Icon(
                _isLoginMode ? Icons.login : Icons.person_add,
                size: 100,
                color: Theme.of(context).primaryColor,
              ),
              const SizedBox(height: 30),

              // Email Input
              TextField(
                controller: _emailController,
                decoration: InputDecoration(
                  labelText: 'Email',
                  border: OutlineInputBorder(borderRadius: BorderRadius.circular(10)),
                  prefixIcon: const Icon(Icons.email),
                ),
                keyboardType: TextInputType.emailAddress,
              ),
              const SizedBox(height: 15),

              // Password Input
              TextField(
                controller: _passwordController,
                decoration: InputDecoration(
                  labelText: 'Password',
                  border: OutlineInputBorder(borderRadius: BorderRadius.circular(10)),
                  prefixIcon: const Icon(Icons.lock),
                ),
                obscureText: true,
              ),
              const SizedBox(height: 25),

              // Submit Button
              _isLoading
                  ? const CircularProgressIndicator.adaptive()
                  : SizedBox(
                      width: double.infinity,
                      child: ElevatedButton(
                        style: ElevatedButton.styleFrom(
                          padding: const EdgeInsets.symmetric(vertical: 15),
                          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
                        ),
                        onPressed: () => _authenticate(context),
                        child: Text(_isLoginMode ? 'Login' : 'Sign Up', style: const TextStyle(fontSize: 18)),
                      ),
                    ),
              const SizedBox(height: 15),

              // Toggle Auth Mode
              TextButton(
                onPressed: () {
                  setState(() {
                    _isLoginMode = !_isLoginMode;
                    _emailController.clear();
                    _passwordController.clear();
                  });
                },
                child: Text(
                  _isLoginMode ? 'Don\'t have an account? Sign Up' : 'Already have an account? Login',
                  style: TextStyle(color: Theme.of(context).primaryColor),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
J. lib/screens/chat_screen.dart
Dart
// lib/screens/chat_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:scheduler_app/models/message.dart'; // Import Message model
import 'package:scheduler_app/providers/chat_provider.dart'; // Import ChatProvider
import 'package:scheduler_app/providers/user_provider.dart'; // Import UserProvider for current user ID

class ChatScreen extends StatefulWidget {
  const ChatScreen({super.key});

  @override
  State<ChatScreen> createState() => _ChatScreenState();
}

class _ChatScreenState extends State<ChatScreen> {
  final TextEditingController _messageController = TextEditingController();
  final ScrollController _scrollController = ScrollController(); // For auto-scrolling

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      // Load messages for a mock conversation, using current user's ID
      final currentUser = Provider.of<UserProvider>(context, listen: false).currentUser;
      if (currentUser != null) {
        Provider.of<ChatProvider>(context, listen: false).loadMessages(currentUser.id);
      }
    });
  }

  @override
  void dispose() {
    _messageController.dispose();
    _scrollController.dispose();
    super.dispose();
  }

  void _sendMessage(ChatProvider chatProvider, String currentUserId) {
    if (_messageController.text.trim().isNotEmpty) {
      chatProvider.sendMessage(currentUserId, 'friend1', _messageController.text.trim()); // Mock receiver as 'friend1'
      _messageController.clear();
      // Scroll to the bottom after sending a message
      _scrollController.animateTo(
        _scrollController.position.maxScrollExtent,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeOut,
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Consumer<ChatProvider>(
      builder: (context, chatProvider, child) {
        final messages = chatProvider.messages;
        final isLoadingMessages = chatProvider.isLoadingMessages;
        final currentUserId = Provider.of<UserProvider>(context).currentUser?.id; // Get current user ID

        if (currentUserId == null) {
          return const Center(child: Text('Please log in to use chat.'));
        }

        if (isLoadingMessages) {
          return const Center(child: CircularProgressIndicator.adaptive());
        }

        return Column(
          children: [
            Expanded(
              child: messages.isEmpty
                  ? const Center(
                      child: Text(
                        'No messages yet. Start a conversation!',
                        style: TextStyle(fontSize: 18, color: Colors.grey),
                      ),
                    )
                  : ListView.builder(
                      controller: _scrollController, // Attach scroll controller
                      padding: const EdgeInsets.all(8.0),
                      itemCount: messages.length,
                      itemBuilder: (context, index) {
                        final message = messages[index];
                        final isMe = message.senderId == currentUserId;
                        return Align(
                          alignment: isMe ? Alignment.centerRight : Alignment.centerLeft,
                          child: Container(
                            margin: const EdgeInsets.symmetric(vertical: 4, horizontal: 8),
                            padding: const EdgeInsets.all(10),
                            decoration: BoxDecoration(
                              color: isMe ? Theme.of(context).primaryColor.withOpacity(0.8) : Colors.grey[300],
                              borderRadius: BorderRadius.circular(12),
                            ),
                            child: Column(
                              crossAxisAlignment: isMe ? CrossAxisAlignment.end : CrossAxisAlignment.start,
                              children: [
                                Text(
                                  message.content,
                                  style: TextStyle(color: isMe ? Colors.white : Colors.black),
                                ),
                                const SizedBox(height: 4),
                                Text(
                                  '${message.timestamp.hour}:${message.timestamp.minute.toString().padLeft(2, '0')}',
                                  style: TextStyle(
                                    color: isMe ? Colors.white70 : Colors.grey[600],
                                    fontSize: 10,
                                  ),
                                ),
                              ],
                            ),
                          ),
                        );
                      },
                    ),
            ),
            Padding(
              padding: const EdgeInsets.all(8.0),
              child: Row(
                children: [
                  Expanded(
                    child: TextField(
                      controller: _messageController,
                      decoration: InputDecoration(
                        hintText: 'Type a message...',
                        border: OutlineInputBorder(borderRadius: BorderRadius.circular(20)),
                        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                      ),
                      onSubmitted: (_) => _sendMessage(chatProvider, currentUserId),
                    ),
                  ),
                  const SizedBox(width: 8),
                  FloatingActionButton(
                    onPressed: () => _sendMessage(chatProvider, currentUserId),
                    mini: true,
                    child: const Icon(Icons.send),
                  ),
                ],
              ),
            ),
          ],
        );
      },
    );
  }
}

K. lib/screens/profile_screen.dart
Dart

// lib/screens/profile_screen.dart
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:scheduler_app/models/user.dart';
import 'package:scheduler_app/providers/user_provider.dart'; // Import UserProvider
import 'package:url_launcher/url_launcher.dart';
import 'dart:io'; // For Platform.isIOS
import 'package:firebase_auth/firebase_auth.dart' as fb_auth; // For sign out

class ProfileScreen extends StatefulWidget {
  const ProfileScreen({super.key});

  @override
  State<ProfileScreen> createState() => _ProfileScreenState();
}

class _ProfileScreenState extends State<ProfileScreen> {
  late TextEditingController _bioController;
  late TextEditingController _nameController;
  bool _isEditingBio = false; // Initialized in declaration
  late bool _isAvailable;

  @override
  void initState() {
    super.initState();
    // Initialize controllers with current user data from provider
    // This assumes currentUser is loaded when ProfileScreen is first built
    final userProvider = Provider.of<UserProvider>(context, listen: false);
    _bioController = TextEditingController(text: userProvider.currentUser?.bio ?? '');
    _nameController = TextEditingController(text: userProvider.currentUser?.name ?? '');
    _isAvailable = userProvider.currentUser?.isAvailable ?? false;
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    // Update controllers if currentUser changes (e.g., after initial load or update)
    final userProvider = Provider.of<UserProvider>(context, listen: false);
    // Only update if not currently editing, to avoid clashing with user input
    if (!_isEditingBio) {
      _bioController.text = userProvider.currentUser?.bio ?? '';
      _nameController.text = userProvider.currentUser?.name ?? '';
      _isAvailable = userProvider.currentUser?.isAvailable ?? false;
    }
  }

  @override
  void dispose() {
    _bioController.dispose();
    _nameController.dispose();
    super.dispose();
  }

  // --- Helper methods for launching URLs/emails ---
  Future<void> _launchEmail() async {
    final Uri emailLaunchUri = Uri(
      scheme: 'mailto',
      path: 'support@chronoplan.com',
      queryParameters: {
        'subject': 'ChronoPlan App Support Request',
        'body': 'Dear Support Team,\n\n',
      },
    );
    if (await canLaunchUrl(emailLaunchUri)) {
      await launchUrl(emailLaunchUri);
    } else {
      // ignore: use_build_context_synchronously
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Could not open email client. Please contact support@chronoplan.com directly.'),
          duration: Duration(seconds: 4),
        ),
      );
    }
  }

  Future<void> _launchUrl(String url) async {
    final Uri uri = Uri.parse(url);
    if (await canLaunchUrl(uri)) {
      await launchUrl(uri, mode: LaunchMode.externalApplication);
    } else {
      // ignore: use_build_context_synchronously
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Could not open link. Please check your internet connection or try again later.'),
          duration: const Duration(seconds: 4),
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    const String appVersion = '1.0.0';

    // Use Consumer to react to changes in UserProvider
    return Consumer<UserProvider>(
      builder: (context, userProvider, child) {
        final currentUser = userProvider.currentUser;
        final isLoadingUser = userProvider.isLoadingUser;
        final isSignedIn = fb_auth.FirebaseAuth.instance.currentUser != null;


        if (isLoadingUser && !isSignedIn) { // Show loading only if not signed in yet
          return const Center(child: CircularProgressIndicator.adaptive());
        }

        if (!isSignedIn || currentUser == null) {
          // If not signed in or user data not loaded after sign-in, prompt login
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Text('You need to log in to manage your profile.', style: TextStyle(fontSize: 18, color: Colors.grey)),
                const SizedBox(height: 20),
                ElevatedButton(
                  onPressed: () {
                    // Navigate to AuthScreen (AuthWrapper will handle this)
                    Navigator.of(context).pushAndRemoveUntil(
                      MaterialPageRoute(builder: (context) => const AuthScreen()),
                      (Route<dynamic> route) => false,
                    );
                  },
                  child: const Text('Go to Login'),
                ),
              ],
            ),
          );
        }

        return SingleChildScrollView(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: <Widget>[
              // --- User Profile Section ---
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    'My Profile',
                    style: Theme.of(context).textTheme.headlineSmall?.copyWith(fontWeight: FontWeight.bold),
                  ),
                  // Logout Button
                  TextButton.icon(
                    icon: const Icon(Icons.logout, size: 20),
                    label: const Text('Logout'),
                    onPressed: () async {
                      await userProvider.signOut();
                      // No need to navigate here, AuthWrapper will detect logout
                    },
                  ),
                ],
              ),
              const SizedBox(height: 10),
              Card(
                elevation: 2,
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8.0)),
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      // User Name (Editable)
                      _isEditingBio
                          ? TextField(
                              controller: _nameController,
                              decoration: const InputDecoration(labelText: 'Name', border: OutlineInputBorder()),
                              maxLength: 50,
                            )
                          : Text(
                              currentUser.name,
                              style: Theme.of(context).textTheme.headlineMedium?.copyWith(fontWeight: FontWeight.bold),
                            ),
                      const SizedBox(height: 8),
                      // User Email (Non-editable for now)
                      Text(
                        currentUser.email,
                        style: TextStyle(fontSize: 16, color: Colors.grey[700]),
                      ),
                      const SizedBox(height: 15),

                      // User Bio (Editable)
                      Text(
                        'Bio (${_bioController.text.length}/500)',
                        style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
                      ),
                      const SizedBox(height: 8),
                      _isEditingBio
                          ? TextField(
                              controller: _bioController,
                              decoration: const InputDecoration(
                                labelText: 'Tell us about yourself',
                                border: OutlineInputBorder(),
                              ),
                              maxLines: 4,
                              maxLength: 500,
                              keyboardType: TextInputType.multiline,
                            )
                          : Text(
                              currentUser.bio.isNotEmpty ? currentUser.bio : 'No bio set.',
                              style: TextStyle(fontSize: 15, color: Colors.grey[800]),
                            ),
                      const SizedBox(height: 15),

                      // Availability Status (Adaptive Switch)
                      Row(
                        children: [
                          Text(
                            'Available for collaboration',
                            style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
                          ),
                          const Spacer(),
                          Switch.adaptive( // Adaptive Switch
                            value: _isAvailable,
                            onChanged: (bool value) {
                              setState(() {
                                _isAvailable = value;
                              });
                            },
                            activeColor: Theme.of(context).primaryColor,
                          ),
                          Container(
                            width: 12,
                            height: 12,
                            decoration: BoxDecoration(
                              shape: BoxShape.circle,
                              color: _isAvailable ? Colors.green : Colors.red,
                            ),
                            margin: const EdgeInsets.only(left: 8),
                          ),
                        ],
                      ),
                      const SizedBox(height: 15),

                      // Edit/Save Button for Bio
                      SizedBox(
                        width: double.infinity,
                        child: _isEditingBio
                            ? ElevatedButton.icon(
                                onPressed: () async {
                                  if (_nameController.text.trim().isEmpty) {
                                     ScaffoldMessenger.of(context).showSnackBar(
                                       const SnackBar(content: Text('Name cannot be empty!'), backgroundColor: Colors.orange),
                                     );
                                     return;
                                  }
                                  final updatedUser = User(
                                    id: currentUser.id,
                                    name: _nameController.text.trim(),
                                    email: currentUser.email,
                                    bio: _bioController.text.trim(),
                                    isAvailable: _isAvailable,
                                    profileImageUrl: currentUser.profileImageUrl,
                                  );
                                  await userProvider.updateCurrentUserProfile(updatedUser);
                                  setState(() {
                                    _isEditingBio = false; // Exit editing mode
                                  });
                                  ScaffoldMessenger.of(context).showSnackBar(
                                    const SnackBar(content: Text('Profile updated!'), backgroundColor: Colors.green),
                                  );
                                },
                                icon: const Icon(Icons.save),
                                label: const Text('Save Profile'),
                              )
                            : OutlinedButton.icon(
                                onPressed: () {
                                  setState(() {
                                    _isEditingBio = true; // Enter editing mode
                                    // Set controllers based on current user data when entering edit mode
                                    _nameController.text = currentUser.name;
                                    _bioController.text = currentUser.bio;
                                    _isAvailable = currentUser.isAvailable;
                                  });
                                },
                                icon: const Icon(Icons.edit),
                                label: const Text('Edit Profile'),
                              ),
                      ),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 25),

              // --- About ChronoPlan Section ---
              Text(
                'About ChronoPlan',
                style: Theme.of(context).textTheme.headlineSmall?.copyWith(fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 10),
              Card(
                elevation: 2,
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8.0)),
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      const Text(
                        'Your personal scheduler, alarm, and task manager.',
                        style: TextStyle(fontSize: 16),
                      ),
                      const SizedBox(height: 10),
                      Text(
                        'Version: $appVersion',
                        style: TextStyle(fontSize: 14, color: Colors.grey[700]),
                      ),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 25),

              // --- Support Section ---
              Text(
                'Support',
                style: Theme.of(context).textTheme.headlineSmall?.copyWith(fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 10),
              Card(
                elevation: 2,
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8.0)),
                child: Column(
                  children: [
                    ListTile(
                      leading: const Icon(Icons.email_outlined, color: Colors.blueGrey),
                      title: const Text('Contact Us'),
                      subtitle: const Text('Send us an email for support'),
                      trailing: const Icon(Icons.arrow_forward_ios, size: 18),
                      onTap: _launchEmail,
                    ),
                    const Divider(height: 1, indent: 16, endIndent: 16),
                    ListTile(
                      leading: const Icon(Icons.help_outline, color: Colors.blueGrey),
                      title: const Text('FAQs'),
                      subtitle: const Text('Frequently Asked Questions (Coming Soon!)'),
                      trailing: const Icon(Icons.arrow_forward_ios, size: 18),
                      onTap: () {
                        ScaffoldMessenger.of(context).showSnackBar(
                          const SnackBar(content: Text('FAQs coming soon!'), duration: Duration(seconds: 1)),
                        );
                      },
                    ),
                  ],
                ),
              ),
              const SizedBox(height: 25),

              // --- Legal Information Section ---
              Text(
                'Legal',
                style: Theme.of(context).textTheme.headlineSmall?.copyWith(fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 10),
              Card(
                elevation: 2,
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8.0)),
                child: Column(
                  children: [
                    ListTile(
                      leading: const Icon(Icons.privacy_tip_outlined, color: Colors.blueGrey),
                      title: const Text('Privacy Policy'),
                      trailing: const Icon(Icons.open_in_new, size: 18),
                      onTap: () => _launchUrl('https://www.example.com/privacy'),
                    ),
                    const Divider(height: 1, indent: 16, endIndent: 16),
                    ListTile(
                      leading: const Icon(Icons.description_outlined, color: Colors.blueGrey),
                      title: const Text('Terms of Service'),
                      trailing: const Icon(Icons.open_in_new, size: 18),
                      onTap: () => _launchUrl('https://www.example.com/terms'),
                    ),
                  ],
                ),
              ),
              const SizedBox(height: 25),
            ],
          ),
        );
      },
    );
  }
}

L. lib/screens/schedule_screen.dart
Dart
// lib/screens/schedule_screen.dart

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:scheduler_app/task.dart';
import 'package:scheduler_app/providers/task_provider.dart';
import 'dart:io'; // For Platform.isIOS
import 'package:flutter/cupertino.dart'; // For Cupertino widgets

class ScheduleScreen extends StatefulWidget {
  const ScheduleScreen({super.key});

  @override
  State<ScheduleScreen> createState() => _ScheduleScreenState();
}

class _ScheduleScreenState extends State<ScheduleScreen> {
  final TextEditingController _taskController = TextEditingController();
  DateTime? _selectedDate;
  TimeOfDay? _selectedTime;

  @override
  void dispose() {
    _taskController.dispose();
    super.dispose();
  }

  // --- Date/Time Selection Methods (for new task input) ---
  // Adapted to show Cupertino pickers on iOS
  Future<void> _selectDate(BuildContext context) async {
    DateTime? pickedDate;
    if (Platform.isIOS) {
      // Show Cupertino Date Picker for iOS
      await showCupertinoModalPopup(
        context: context,
        builder: (BuildContext context) {
          return Container(
            height: 250,
            color: CupertinoColors.systemBackground.resolveFrom(context),
            child: Column(
              children: [
                Align(
                  alignment: Alignment.centerRight,
                  child: CupertinoButton(
                    onPressed: () => Navigator.of(context).pop(),
                    child: const Text('Done'),
                  ),
                ),
                Expanded(
                  child: CupertinoDatePicker(
                    mode: CupertinoDatePickerMode.date,
                    initialDateTime: _selectedDate ?? DateTime.now(),
                    minimumDate: DateTime(2000),
                    maximumDate: DateTime(2101),
                    onDateTimeChanged: (DateTime newDate) {
                      pickedDate = newDate;
                    },
                  ),
                ),
              ],
            ),
          );
        },
      );
    } else {
      // Show Material Date Picker for Android/others
      pickedDate = await showDatePicker(
        context: context,
        initialDate: _selectedDate ?? DateTime.now(),
        firstDate: DateTime(2000),
        lastDate: DateTime(2101),
        helpText: 'Select Task Date',
        confirmText: 'SELECT',
        cancelText: 'CANCEL',
      );
    }

    if (pickedDate != null && pickedDate != _selectedDate) {
      setState(() {
        _selectedDate = pickedDate;
      });
    }
  }

  // Adapted to show Cupertino pickers on iOS
  Future<void> _selectTime(BuildContext context) async {
    TimeOfDay? pickedTime;
    if (Platform.isIOS) {
      // Show Cupertino Time Picker for iOS
      await showCupertinoModalPopup(
        context: context,
        builder: (BuildContext context) {
          return Container(
            height: 250,
            color: CupertinoColors.systemBackground.resolveFrom(context),
            child: Column(
              children: [
                Align(
                  alignment: Alignment.centerRight,
                  child: CupertinoButton(
                    onPressed: () => Navigator.of(context).pop(),
                    child: const Text('Done'),
                  ),
                ),
                Expanded(
                  child: CupertinoDatePicker(
                    mode: CupertinoDatePickerMode.time,
                    initialDateTime: DateTime(2000, 1, 1, _selectedTime?.hour ?? TimeOfDay.now().hour, _selectedTime?.minute ?? TimeOfDay.now().minute),
                    onDateTimeChanged: (DateTime newDateTime) {
                      pickedTime = TimeOfDay.fromDateTime(newDateTime);
                    },
                  ),
                ),
              ],
            ),
          );
        },
      );
    } else {
      // Show Material Time Picker for Android/others
      pickedTime = await showTimePicker(
        context: context,
        initialTime: _selectedTime ?? TimeOfDay.now(),
        helpText: 'Select Task Time',
        confirmText: 'SELECT',
        cancelText: 'CANCEL',
      );
    }

    if (pickedTime != null && pickedTime != _selectedTime) {
      setState(() {
        _selectedTime = pickedTime;
      });
    }
  }

  // --- Date/Time Picker Helper for Dialog (also adapted) ---
  Future<DateTime?> _pickDateForDialog(BuildContext context, DateTime? initialDate) async {
    if (Platform.isIOS) {
      DateTime? pickedDate;
      await showCupertinoModalPopup(
        context: context,
        builder: (BuildContext context) {
          return Container(
            height: 250,
            color: CupertinoColors.systemBackground.resolveFrom(context),
            child: Column(
              children: [
                Align(
                  alignment: Alignment.centerRight,
                  child: CupertinoButton(
                    onPressed: () => Navigator.of(context).pop(),
                    child: const Text('Done'),
                  ),
                ),
                Expanded(
                  child: CupertinoDatePicker(
                    mode: CupertinoDatePickerMode.date,
                    initialDateTime: initialDate ?? DateTime.now(),
                    minimumDate: DateTime(2000),
                    maximumDate: DateTime(2101),
                    onDateTimeChanged: (DateTime newDate) {
                      pickedDate = newDate;
                    },
                  ),
                ),
              ],
            ),
          );
        },
      );
      return pickedDate;
    } else {
      return await showDatePicker(
        context: context,
        initialDate: initialDate ?? DateTime.now(),
        firstDate: DateTime(2000),
        lastDate: DateTime(2101),
      );
    }
  }

  Future<TimeOfDay?> _pickTimeForDialog(BuildContext context, TimeOfDay? initialTime) async {
    if (Platform.isIOS) {
      TimeOfDay? pickedTime;
      await showCupertinoModalPopup(
        context: context,
        builder: (BuildContext context) {
          return Container(
            height: 250,
            color: CupertinoColors.systemBackground.resolveFrom(context),
            child: Column(
              children: [
                Align(
                  alignment: Alignment.centerRight,
                  child: CupertinoButton(
                    onPressed: () => Navigator.of(context).pop(),
                    child: const Text('Done'),
                  ),
                ),
                Expanded(
                  child: CupertinoDatePicker(
                    mode: CupertinoDatePickerMode.time,
                    initialDateTime: DateTime(2000, 1, 1, initialTime?.hour ?? TimeOfDay.now().hour, initialTime?.minute ?? TimeOfDay.now().minute),
                    onDateTimeChanged: (DateTime newDateTime) {
                      pickedTime = TimeOfDay.fromDateTime(newDateTime);
                    },
                  ),
                ),
              ],
            ),
          );
        },
      );
      return pickedTime;
    } else {
      return await showTimePicker(
        context: context,
        initialTime: initialTime ?? TimeOfDay.now(),
      );
    }
  }


  // --- Adaptive Dialogs ---
  // _confirmRemoveTask (modified to use adaptive dialog)
  Future<bool> _confirmRemoveTask(int index) async {
    final taskTitle = context.read<TaskProvider>().tasks[index].title;
    final bool confirm = await (Platform.isIOS
        ? showCupertinoDialog( // Cupertino dialog for iOS
            context: context,
            builder: (BuildContext context) {
              return CupertinoAlertDialog(
                title: const Text('Confirm Deletion'),
                content: Text('Are you sure you want to delete "$taskTitle"?'),
                actions: <Widget>[
                  CupertinoDialogAction(
                    onPressed: () => Navigator.of(context).pop(false),
                    child: const Text('Cancel'),
                  ),
                  CupertinoDialogAction(
                    onPressed: () => Navigator.of(context).pop(true),
                    isDestructiveAction: true, // Red text for destructive action
                    child: const Text('Delete'),
                  ),
                ],
              );
            },
          )
        : showDialog( // Material dialog for Android/others
            context: context,
            builder: (BuildContext context) {
              return AlertDialog(
                title: const Text('Confirm Deletion'),
                content: Text('Are you sure you want to delete "$taskTitle"?'),
                actions: <Widget>[
                  TextButton(
                    onPressed: () => Navigator.of(context).pop(false),
                    child: const Text('Cancel'),
                  ),
                  TextButton(
                    onPressed: () => Navigator.of(context).pop(true),
                    child: const Text('Delete', style: TextStyle(color: Colors.red)),
                  ),
                ],
              );
            },
          )) ??
        false;

    if (confirm) {
      // ignore: use_build_context_synchronously
      context.read<TaskProvider>().removeTask(index);
    }
    return confirm;
  }

  // _showTaskDetailsDialog (modified to use adaptive dialog)
  Future<void> _showTaskDetailsDialog(Task task, int originalIndex, TaskProvider taskProvider) async {
    final TextEditingController titleController = TextEditingController(text: task.title);
    DateTime? dialogSelectedDate = task.scheduledDate;
    TimeOfDay? dialogSelectedTime = task.scheduledTime;
    bool dialogIsCompleted = task.isCompleted;

    await (Platform.isIOS
        ? showCupertinoDialog( // Cupertino dialog for iOS
            context: context,
            builder: (BuildContext dialogContext) {
              return StatefulBuilder(
                builder: (BuildContext context, StateSetter setDialogState) {
                  return CupertinoAlertDialog( // Cupertino style
                    title: const Text('Edit Task'),
                    content: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        CupertinoTextField( // Cupertino TextField
                          controller: titleController,
                          placeholder: 'Task Title',
                          decoration: BoxDecoration(
                            border: Border.all(color: CupertinoColors.lightBackgroundGray),
                            borderRadius: BorderRadius.circular(5.0),
                          ),
                        ),
                        const SizedBox(height: 10),
                        // Date and Time fields adapted for Cupertino
                        _buildCupertinoDateTimePickers(context, setDialogState, dialogSelectedDate, dialogSelectedTime, (date) => dialogSelectedDate = date, (time) => dialogSelectedTime = time),
                        const SizedBox(height: 10),
                        Row(
                          mainAxisAlignment: MainAxisAlignment.center, // Center the checkbox
                          children: [
                            CupertinoSwitch( // Cupertino Switch
                              value: dialogIsCompleted,
                              onChanged: (bool value) {
                                setDialogState(() {
                                  dialogIsCompleted = value;
                                });
                              },
                              activeColor: Theme.of(context).primaryColor,
                            ),
                            const SizedBox(width: 8),
                            const Text('Mark as Completed'),
                          ],
                        ),
                      ],
                    ),
                    actions: <Widget>[
                      CupertinoDialogAction(
                        onPressed: () => Navigator.of(context).pop(),
                        child: const Text('Cancel'),
                      ),
                      CupertinoDialogAction(
                        onPressed: () {
                          if (titleController.text.trim().isNotEmpty) {
                            final updatedTask = Task(
                              title: titleController.text.trim(),
                              scheduledDate: dialogSelectedDate,
                              scheduledTime: dialogSelectedTime,
                              isCompleted: dialogIsCompleted,
                            );
                            taskProvider.updateTask(originalIndex, updatedTask);
                            Navigator.of(context).pop();
                          } else {
                             ScaffoldMessenger.of(context).showSnackBar(
                               const SnackBar(
                                 content: Text('Task title cannot be empty!'),
                                 duration: Duration(seconds: 1),
                                 backgroundColor: Colors.orange,
                               ),
                             );
                          }
                        },
                        child: const Text('Save Changes'),
                      ),
                    ],
                  );
                },
              );
            },
          )
        : showDialog( // Material dialog for Android/others
            context: context,
            builder: (BuildContext dialogContext) {
              return StatefulBuilder(
                builder: (BuildContext context, StateSetter setDialogState) {
                  return AlertDialog(
                    title: const Text('Edit Task'),
                    content: SingleChildScrollView(
                      child: Column(
                        mainAxisSize: MainAxisSize.min,
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          TextField(
                            controller: titleController,
                            decoration: const InputDecoration(
                              labelText: 'Task Title',
                              border: OutlineInputBorder(),
                            ),
                          ),
                          const SizedBox(height: 15),
                          Row(
                            children: [
                              Expanded(
                                child: GestureDetector(
                                  onTap: () async {
                                    final picked = await _pickDateForDialog(context, dialogSelectedDate);
                                    if (picked != null) {
                                      setDialogState(() {
                                        dialogSelectedDate = picked;
                                      });
                                    }
                                  },
                                  child: AbsorbPointer(
                                    child: TextField(
                                      controller: TextEditingController(
                                        text: Task(title: '', scheduledDate: dialogSelectedDate).formattedDate,
                                      ),
                                      decoration: InputDecoration(
                                        labelText: 'Date',
                                        border: const OutlineInputBorder(),
                                        prefixIcon: const Icon(Icons.calendar_today),
                                        suffixIcon: dialogSelectedDate != null ? IconButton(
                                          icon: const Icon(Icons.clear, size: 20),
                                          onPressed: () {
                                            setDialogState(() {
                                              dialogSelectedDate = null;
                                            });
                                          },
                                        ) : null,
                                      ),
                                    ),
                                  ),
                                ),
                              ),
                              const SizedBox(width: 10),
                              Expanded(
                                child: GestureDetector(
                                  onTap: () async {
                                    final picked = await _pickTimeForDialog(context, dialogSelectedTime);
                                    if (picked != null) {
                                      setDialogState(() {
                                        dialogSelectedTime = picked;
                                      });
                                    }
                                  },
                                  child: AbsorbPointer(
                                    child: TextField(
                                      controller: TextEditingController(
                                        text: Task(title: '', scheduledTime: dialogSelectedTime).formattedTime,
                                      ),
                                      decoration: InputDecoration(
                                        labelText: 'Time',
                                        border: const OutlineInputBorder(),
                                        prefixIcon: const Icon(Icons.access_time),
                                        suffixIcon: dialogSelectedTime != null ? IconButton(
                                          icon: const Icon(Icons.clear, size: 20),
                                          onPressed: () {
                                            setDialogState(() {
                                              dialogSelectedTime = null;
                                            });
                                          },
                                        ) : null,
                                      ),
                                    ),
                                  ),
                                ),
                              ),
                            ],
                          ),
                          const SizedBox(height: 15),
                          Row(
                            children: [
                              Checkbox(
                                value: dialogIsCompleted,
                                onChanged: (bool? value) {
                                  setDialogState(() {
                                    dialogIsCompleted = value ?? false;
                                  });
                                },
                                activeColor: Theme.of(context).primaryColor,
                              ),
                              const Text('Mark as Completed'),
                            ],
                          ),
                        ],
                      ),
                    ),
                    actions: <Widget>[
                      TextButton(
                        onPressed: () => Navigator.of(context).pop(),
                        child: const Text('Cancel'),
                      ),
                      ElevatedButton(
                        onPressed: () {
                          if (titleController.text.trim().isNotEmpty) {
                            final updatedTask = Task(
                              title: titleController.text.trim(),
                              scheduledDate: dialogSelectedDate,
                              scheduledTime: dialogSelectedTime,
                              isCompleted: dialogIsCompleted,
                            );
                            taskProvider.updateTask(originalIndex, updatedTask);
                            Navigator.of(context).pop();
                          } else {
                             ScaffoldMessenger.of(context).showSnackBar(
                               const SnackBar(
                                 content: Text('Task title cannot be empty!'),
                                 duration: Duration(seconds: 1),
                                 backgroundColor: Colors.orange,
                               ),
                             );
                          }
                        },
                        child: const Text('Save Changes'),
                      ),
                    ],
                  );
                },
              );
            },
          )) ??
        false;

    titleController.dispose();
  }

  // NEW Helper: Builds platform-adaptive date/time input fields for dialog
  Widget _buildCupertinoDateTimePickers(
    BuildContext context,
    StateSetter setDialogState,
    DateTime? dialogSelectedDate,
    TimeOfDay? dialogSelectedTime,
    Function(DateTime?) onDateChanged,
    Function(TimeOfDay?) onTimeChanged,
  ) {
    return Column(
      children: [
        GestureDetector(
          onTap: () async {
            final picked = await _pickDateForDialog(context, dialogSelectedDate);
            if (picked != null) {
              setDialogState(() {
                onDateChanged(picked);
              });
            }
          },
          child: AbsorbPointer(
            child: CupertinoTextField( // Cupertino TextField
              placeholder: 'Select Date',
              controller: TextEditingController(
                text: Task(title: '', scheduledDate: dialogSelectedDate).formattedDate,
              ),
              readOnly: true, // Make it read-only for tap
              decoration: BoxDecoration(
                border: Border.all(color: CupertinoColors.lightBackgroundGray),
                borderRadius: BorderRadius.circular(5.0),
              ),
              prefix: const Padding(
                padding: EdgeInsets.only(left: 8.0),
                child: Icon(CupertinoIcons.calendar), // Cupertino icon
              ),
              suffix: dialogSelectedDate != null
                  ? CupertinoButton(
                      padding: EdgeInsets.zero,
                      child: const Icon(CupertinoIcons.clear_circled_solid, size: 20),
                      onPressed: () {
                        setDialogState(() {
                          onDateChanged(null);
                        });
                      },
                    )
                  : null,
            ),
          ),
        ),
        const SizedBox(height: 10),
        GestureDetector(
          onTap: () async {
            final picked = await _pickTimeForDialog(context, dialogSelectedTime);
            if (picked != null) {
              setDialogState(() {
                onTimeChanged(picked);
              });
            }
          },
          child: AbsorbPointer(
            child: CupertinoTextField( // Cupertino TextField
              placeholder: 'Select Time',
              controller: TextEditingController(
                text: Task(title: '', scheduledTime: dialogSelectedTime).formattedTime,
              ),
              readOnly: true, // Make it read-only for tap
              decoration: BoxDecoration(
                border: Border.all(color: CupertinoColors.lightBackgroundGray),
                borderRadius: BorderRadius.circular(5.0),
              ),
              prefix: const Padding(
                padding: EdgeInsets.only(left: 8.0),
                child: Icon(CupertinoIcons.time), // Cupertino icon
              ),
              suffix: dialogSelectedTime != null
                  ? CupertinoButton(
                      padding: EdgeInsets.zero,
                      child: const Icon(CupertinoIcons.clear_circled_solid, size: 20),
                      onPressed: () {
                        setDialogState(() {
                          onTimeChanged(null);
                        });
                      },
                    )
                  : null,
            ),
          ),
        ),
      ],
    );
  }

  @override
  Widget build(BuildContext context) {
    // ... (rest of build method is largely unchanged, but uses the adaptive elements) ...
    return Consumer<TaskProvider>(
      builder: (context, taskProvider, child) {
        final tasks = taskProvider.tasks;
        final isLoadingTasks = taskProvider.isLoadingTasks;
        final groupedTasks = taskProvider.groupedTasks;
        final sortedHeaders = taskProvider.sortedHeaders;

        // Define _addTask here (now calls provider)
        void _addTask() {
          if (_taskController.text.trim().isNotEmpty) {
            taskProvider.addTask(
              Task(
                title: _taskController.text.trim(),
                scheduledDate: _selectedDate,
                scheduledTime: _selectedTime,
              ),
            );
            _taskController.clear();
            setState(() { // setState for local UI state (input fields)
              _selectedDate = null;
              _selectedTime = null;
            });
          } else {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Task title cannot be empty!'),
                duration: Duration(seconds: 1),
                backgroundColor: Colors.orange,
              ),
            );
          }
        }

        // Define _toggleTaskCompletion here (now calls provider)
        void _toggleTaskCompletion(int index, bool? value) {
          taskProvider.toggleTaskCompletion(index, value); // Call provider's toggle method
        }

        return Column(
          children: <Widget>[
            // ... (Input Section is mostly unchanged, uses regular Material widgets,
            // but the date/time pickers are now adaptive via _selectDate/_selectTime) ...
            Card(
              margin: const EdgeInsets.all(16.0),
              elevation: 4,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12.0)),
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'Add New Task',
                      style: Theme.of(context).textTheme.headlineSmall?.copyWith(fontWeight: FontWeight.bold),
                    ),
                    const SizedBox(height: 15),
                    TextField(
                      controller: _taskController,
                      decoration: InputDecoration(
                        labelText: 'Task Title',
                        hintText: 'e.g., Study Flutter, Call Mom',
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(8.0),
                        ),
                        prefixIcon: const Icon(Icons.edit_note),
                      ),
                      onSubmitted: (_) => _addTask(),
                    ),
                    const SizedBox(height: 10),

                    Row(
                      children: [
                        Expanded(
                          child: Tooltip(
                            message: _selectedDate?.formattedDate ?? 'Tap to select date',
                            child: GestureDetector(
                              onTap: () => _selectDate(context),
                              child: AbsorbPointer(
                                child: TextField(
                                  controller: TextEditingController(
                                    text: _selectedDate?.formattedDate ?? 'Select Date',
                                  ),
                                  decoration: InputDecoration(
                                    labelText: 'Date',
                                    border: OutlineInputBorder(borderRadius: BorderRadius.circular(8.0)),
                                    prefixIcon: const Icon(Icons.calendar_today),
                                    suffixIcon: _selectedDate != null ? IconButton(
                                      icon: const Icon(Icons.clear, size: 20),
                                      onPressed: () {
                                        setState(() {
                                          _selectedDate = null;
                                        });
                                      },
                                    ) : null,
                                  ),
                                ),
                              ),
                            ),
                          ),
                        ),
                        const SizedBox(width: 10),
                        Expanded(
                          child: Tooltip(
                            message: _selectedTime?.formattedTime ?? 'Tap to select time',
                            child: GestureDetector(
                              onTap: () => _selectTime(context),
                              child: AbsorbPointer(
                                child: TextField(
                                  controller: TextEditingController(
                                    text: _selectedTime?.formattedTime ?? 'Select Time',
                                  ),
                                  decoration: InputDecoration(
                                    labelText: 'Time',
                                    border: OutlineInputBorder(borderRadius: BorderRadius.circular(8.0)),
                                    prefixIcon: const Icon(Icons.access_time),
                                    suffixIcon: _selectedTime != null ? IconButton(
                                      icon: const Icon(Icons.clear, size: 20),
                                      onPressed: () {
                                        setState(() {
                                          _selectedTime = null;
                                        });
                                      },
                                    ) : null,
                                  ),
                                ),
                              ),
                            ),
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 15),
                    SizedBox(
                      width: double.infinity,
                      child: ElevatedButton.icon(
                        onPressed: _addTask,
                        style: ElevatedButton.styleFrom(
                          padding: const EdgeInsets.symmetric(vertical: 15),
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(8.0),
                          ),
                        ),
                        icon: const Icon(Icons.add),
                        label: const Text('Add Task'),
                      ),
                    ),
                  ],
                ),
              ),
            ),
            Expanded(
              child: isLoadingTasks
                  ? const Center(child: CircularProgressIndicator.adaptive())
                  : tasks.isEmpty
                      ? Center(
                          child: Column(
                            mainAxisAlignment: MainAxisAlignment.center,
                            children: [
                              Icon(Icons.checklist, size: 80, color: Colors.grey[300]),
                              const SizedBox(height: 10),
                              Text(
                                'Your schedule is clear!',
                                style: TextStyle(fontSize: 22, fontWeight: FontWeight.bold, color: Colors.grey[600]),
                              ),
                              const SizedBox(height: 5),
                              Text(
                                'Add your first task above.',
                                style: TextStyle(fontSize: 16, color: Colors.grey[500]),
                              ),
                            ],
                          ),
                        )
                      : ListView.builder(
                          itemCount: sortedHeaders.length,
                          itemBuilder: (context, headerIndex) {
                            final header = sortedHeaders[headerIndex];
                            final tasksInGroup = groupedTasks[header]!;
                            return Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Padding(
                                  padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 8),
                                  child: Text(
                                    header,
                                    style: Theme.of(context).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.bold),
                                  ),
                                ),
                                ListView.separated(
                                  shrinkWrap: true,
                                  physics: const NeverScrollableScrollPhysics(),
                                  itemCount: tasksInGroup.length,
                                  separatorBuilder: (context, index) => const Divider(
                                    indent: 20,
                                    endIndent: 20,
                                    height: 1,
                                  ),
                                  itemBuilder: (context, taskIndex) {
                                    final task = tasksInGroup[taskIndex];
                                    final originalIndex = tasks.indexOf(task);

                                    return Dismissible(
                                      key: Key(task.title + task.hashCode.toString()),
                                      direction: DismissDirection.endToStart,
                                      background: Container(
                                        color: Colors.red,
                                        alignment: Alignment.centerRight,
                                        padding: const EdgeInsets.symmetric(horizontal: 20),
                                        child: const Icon(Icons.delete, color: Colors.white),
                                      ),
                                      confirmDismiss: (direction) async {
                                        return await _confirmRemoveTask(originalIndex);
                                      },
                                      onDismissed: (direction) {
                                        // Task is already removed by _confirmRemoveTask if confirmed
                                      },
                                      child: Card(
                                        margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
                                        elevation: 1,
                                        color: task.isCompleted ? Colors.green[50] : Theme.of(context).cardColor,
                                        child: ListTile(
                                          leading: Checkbox(
                                            value: task.isCompleted,
                                            onChanged: (bool? value) {
                                              _toggleTaskCompletion(originalIndex, value);
                                            },
                                            activeColor: Theme.of(context).primaryColor,
                                          ),
                                          title: Text(
                                            task.title,
                                            style: TextStyle(
                                              fontSize: 16,
                                              fontWeight: FontWeight.w500,
                                              decoration: task.isCompleted ? TextDecoration.lineThrough : TextDecoration.none,
                                              color: task.isCompleted ? Colors.grey[600] : Colors.black,
                                            ),
                                          ),
                                          subtitle: Text(
                                            '${task.formattedDate} ${task.formattedTime}',
                                            style: TextStyle(
                                              fontSize: 14,
                                              color: task.isCompleted ? Colors.grey[500] : Colors.grey[700],
                                              decoration: task.isCompleted ? TextDecoration.lineThrough : TextDecoration.none,
                                            ),
                                          ),
                                          trailing: IconButton(
                                            icon: const Icon(Icons.delete_outline, color: Colors.redAccent),
                                            onPressed: () => _confirmRemoveTask(originalIndex),
                                          ),
                                          onTap: () {
                                            _showTaskDetailsDialog(task, originalIndex, taskProvider);
                                          },
                                        ),
                                      ),
                                    );
                                  },
                                ),
                              ],
                            );
                          },
                        ),
            ),
          ],
        );
      },
    );
  }
}

5. How to Run the App
Ensure Firebase Setup is Complete: Verify all manual steps (Firebase project, app registration, google-services.json/GoogleService-Info.plist, flutterfire configure) are done.
Open your project in your IDE (VS Code, Android Studio).
Check pubspec.yaml: Make sure all dependencies are listed and flutter pub get has been run successfully.
Launch an Emulator/Connect a Device:
Android: Open Android Studio -> AVD Manager -> Launch an emulator.
iOS: Open Xcode -> Product -> Destination -> Choose a simulator.
Physical Device: Connect your phone via USB and ensure developer options (Android) or enable developer mode (iOS 16+) are enabled and device is recognized by flutter devices.
Run the App:
From IDE: Click the "Run" or "Debug" button.
From Terminal: In your project root, run flutter run.
The app should launch! You will first be greeted by the AuthScreen where you can "Sign Up" with an email and password (which will create a user in Firebase Authentication), or "Login" if you already have an account. Once authenticated, you will be taken to the MainAppScreen with its tabs.

6. How to Run Tests
Ensure mockito and build_runner are in dev_dependencies in your pubspec.yaml and you've run flutter pub get.
Generate Mocks (if needed): If mockito gives compilation errors about missing files (e.g., *.mocks.dart), run:

Bash
flutter pub run build_runner build
(You might need to run this command again if you change test/mock_shared_preferences.dart or other files that use mockito's code generation).
Open your terminal in the root directory of your ChronoPlan project (chronoplan_app/).
Run Tests:
To run all tests:
Bash
flutter test
To run specific unit tests:
Bash
flutter test test/unit/task_model_test.dart
flutter test test/unit/task_provider_test.dart
To run specific widget tests:
Bash
flutter test test/widget/schedule_screen_widget_test.dart
To run tests continually on file changes (useful during development):
Bash
flutter test --watch
You should see output in your terminal indicating whether the tests passed or failed.

This is the complete ChronoPlan application as we've built it. You now have a strong, maintainable, and testable foundation for your project!
