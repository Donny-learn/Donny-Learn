// lib/main.dart

import 'package:flutter/material.dart';
import 'package:scheduler_app/task.dart'; // Import our Task model
import 'package:shared_preferences/shared_preferences.dart'; // Import for local persistence
import 'dart:convert'; // Required for jsonEncode and jsonDecode

// The main entry point of the Flutter application.
void main() {
  runApp(const MyApp());
}

/// MyApp is the root widget of our application.
/// It sets up the basic Material design theme and navigation.
class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'ChronoPlan', // Updated: The name of the app for the OS (e.g., recent apps list)
      theme: ThemeData(
        primarySwatch: Colors.blueGrey, // Defines the primary color palette
        visualDensity: VisualDensity.adaptivePlatformDensity, // Adapts density for different platforms
        appBarTheme: const AppBarTheme(
          backgroundColor: Colors.blueGrey, // Consistent app bar color
          foregroundColor: Colors.white, // Text/icon color on app bar
        ),
      ),
      home: const MainAppScreen(), // Our application's main screen with navigation
    );
  }
}

/// MainAppScreen: Handles the Bottom Navigation Bar.
/// This StatefulWidget manages the state of the selected tab.
class MainAppScreen extends StatefulWidget {
  const MainAppScreen({super.key});

  @override
  State<MainAppScreen> createState() => _MainAppScreenState();
}

class _MainAppScreenState extends State<MainAppScreen> {
  int _selectedIndex = 0; // The current index of the selected tab (0: Chats, 1: Schedule, 2: Profile)

  /// A list of widgets (screens) that correspond to each tab in the navigation bar.
  final List<Widget> _widgetOptions = <Widget>[
    const ChatScreen(), // Placeholder screen for chat functionality
    const ScheduleScreen(), // Our core schedule/task list screen
    const ProfileScreen(), // Placeholder screen for user profile
  ];

  /// Callback function executed when a BottomNavigationBarItem is tapped.
  /// It updates the `_selectedIndex` and triggers a UI rebuild.
  void _onItemTapped(int index) {
    setState(() {
      _selectedIndex = index;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(
          _selectedIndex == 0
              ? 'Chats'
              : _selectedIndex == 1
                  ? 'My Schedule' // Title for the schedule tab
                  : 'Profile',
        ),
        elevation: 4, // Adds a subtle shadow below the AppBar
      ),
      body: Center(
        child: _widgetOptions.elementAt(_selectedIndex), // Displays the selected screen
      ),
      bottomNavigationBar: BottomNavigationBar(
        items: const <BottomNavigationBarItem>[
          // Define each item in the navigation bar with an icon and a label.
          BottomNavigationBarItem(
            icon: Icon(Icons.chat_bubble_outline),
            label: 'Chats',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.calendar_month_outlined),
            label: 'Schedule',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.person_outline),
            label: 'Profile',
          ),
        ],
        currentIndex: _selectedIndex, // Sets the currently active tab visually
        selectedItemColor: Theme.of(context).primaryColor, // Color for the active icon/label
        unselectedItemColor: Colors.grey[600], // Color for inactive icons/labels
        onTap: _onItemTapped, // The callback function when an item is tapped
        type: BottomNavigationBarType.fixed, // Ensures items are always visible
      ),
    );
  }
}

// --- Placeholder Screens ---
/// ChatScreen: A placeholder for the chat functionality.
class ChatScreen extends StatelessWidget {
  const ChatScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return const Center(
      child: Text(
        'Chat Screen (Coming Soon!)',
        style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold, color: Colors.grey),
      ),
    );
  }
}

/// ProfileScreen: A placeholder for the user profile section.
class ProfileScreen extends StatelessWidget {
  const ProfileScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return const Center(
      child: Text(
        'Profile Screen (Coming Soon!)',
        style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold, color: Colors.grey),
      ),
    );
  }
}

/// ScheduleScreen: Our Core Task/Schedule List.
/// This StatefulWidget manages the list of tasks, including adding, removing,
/// marking as complete, and persisting them locally.
class ScheduleScreen extends StatefulWidget {
  const ScheduleScreen({super.key});

  @override
  State<ScheduleScreen> createState() => _ScheduleScreenState();
}

class _ScheduleScreenState extends State<ScheduleScreen> {
  final List<Task> _tasks = []; // List to hold Task objects
  final TextEditingController _taskController = TextEditingController();
  DateTime? _selectedDate; // Holds the selected date for a new task
  TimeOfDay? _selectedTime; // Holds the selected time for a new task

  // Key for storing tasks in SharedPreferences
  static const String _tasksKey = 'tasks_list';

  @override
  void initState() {
    super.initState();
    _loadTasks(); // Load tasks from storage when the screen initializes
  }

  // --- Persistence Methods ---
  /// Loads tasks from SharedPreferences when the app starts.
  Future<void> _loadTasks() async {
    final prefs = await SharedPreferences.getInstance();
    final String? tasksString = prefs.getString(_tasksKey);

    if (tasksString != null) {
      // Decode the JSON string back into a list of maps
      final List<dynamic> taskMaps = jsonDecode(tasksString);
      setState(() {
        // Convert each map back into a Task object using our fromJson factory
        _tasks.addAll(taskMaps.map((map) => Task.fromJson(map as Map<String, dynamic>)).toList());
        _sortTasks(); // Sort tasks after loading
      });
    }
  }

  /// Saves the current list of tasks to SharedPreferences.
  Future<void> _saveTasks() async {
    final prefs = await SharedPreferences.getInstance();
    // Convert each Task object to a JSON map, then encode the list of maps to a JSON string
    final String tasksString = jsonEncode(_tasks.map((task) => task.toJson()).toList());
    await prefs.setString(_tasksKey, tasksString);
  }

  // --- Date/Time Selection Methods ---
  /// Shows a date picker dialog to select a date for a task.
  Future<void> _selectDate(BuildContext context) async {
    final DateTime? pickedDate = await showDatePicker(
      context: context,
      initialDate: _selectedDate ?? DateTime.now(), // Start with today or previously selected
      firstDate: DateTime(2000), // Earliest selectable date
      lastDate: DateTime(2101), // Latest selectable date
      helpText: 'Select Task Date', // Custom help text for the picker
      confirmText: 'SELECT', // Custom confirm button text
      cancelText: 'CANCEL', // Custom cancel button text
    );
    if (pickedDate != null && pickedDate != _selectedDate) {
      setState(() {
        _selectedDate = pickedDate; // Update the selected date
      });
    }
  }

  /// Shows a time picker dialog to select a time for a task.
  Future<void> _selectTime(BuildContext context) async {
    final TimeOfDay? pickedTime = await showTimePicker(
      context: context,
      initialTime: _selectedTime ?? TimeOfDay.now(), // Start with current time or previously selected
      helpText: 'Select Task Time', // Custom help text
      confirmText: 'SELECT',
      cancelText: 'CANCEL',
    );
    if (pickedTime != null && pickedTime != _selectedTime) {
      setState(() {
        _selectedTime = pickedTime; // Update the selected time
      });
    }
  }

  // --- Task Management Methods ---
  /// Adds a new task to the list if the title is not empty.
  void _addTask() {
    setState(() {
      // Use .trim() to remove leading/trailing whitespace
      if (_taskController.text.trim().isNotEmpty) {
        _tasks.add(
          Task(
            title: _taskController.text.trim(), // Store trimmed title
            scheduledDate: _selectedDate, // Assign selected date
            scheduledTime: _selectedTime, // Assign selected time
          ),
        );
        _taskController.clear(); // Clear the text input
        _selectedDate = null; // Reset selected date
        _selectedTime = null; // Reset selected time
        _sortTasks(); // Sort tasks after adding
        _saveTasks(); // Save tasks after adding
      } else {
        // Provide user feedback for empty input
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Task title cannot be empty!'),
            duration: Duration(seconds: 1),
            backgroundColor: Colors.orange,
          ),
        );
      }
    });
  }

  /// Removes a task from the list at a given index.
  void _removeTask(int index) {
    final taskTitle = _tasks[index].title; // Get title before removing for SnackBar
    setState(() {
      _tasks.removeAt(index);
      _saveTasks(); // Save tasks after removing
    });
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text('Task "$taskTitle" deleted.'),
        duration: const Duration(seconds: 2),
        backgroundColor: Colors.redAccent,
      ),
    );
  }

  /// Toggles the completion status of a task.
  void _toggleTaskCompletion(int index, bool? value) {
    setState(() {
      _tasks[index].isCompleted = value ?? false; // Update completion status
      _sortTasks(); // Re-sort tasks after completion change
      _saveTasks(); // Save changes
    });
  }

  /// Sorts the tasks list based on completion, date, time, and title.
  void _sortTasks() {
    _tasks.sort((a, b) {
      // 1. Prioritize incomplete tasks first
      if (a.isCompleted && !b.isCompleted) return 1;
      if (!a.isCompleted && b.isCompleted) return -1;

      // 2. Then sort by date
      if (a.scheduledDate != null && b.scheduledDate != null) {
        final dateComparison = a.scheduledDate!.compareTo(b.scheduledDate!);
        if (dateComparison != 0) return dateComparison;
      } else if (a.scheduledDate != null) {
        return -1; // Task with date comes before task without
      } else if (b.scheduledDate != null) {
        return 1; // Task with date comes before task without
      }

      // 3. Then sort by time if dates are the same or not present
      if (a.scheduledTime != null && b.scheduledTime != null) {
        // Convert TimeOfDay to minutes for easy comparison
        final timeA = a.scheduledTime!.hour * 60 + a.scheduledTime!.minute;
        final timeB = b.scheduledTime!.hour * 60 + b.scheduledTime!.minute;
        final timeComparison = timeA.compareTo(timeB);
        if (timeComparison != 0) return timeComparison;
      } else if (a.scheduledTime != null) {
        return -1; // Task with time comes before task without
      } else if (b.scheduledTime != null) {
        return 1; // Task with time comes before task without
      }

      // 4. Finally, sort by title alphabetically as a tie-breaker
      return a.title.compareTo(b.title);
    });
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: <Widget>[
        // --- Input Section: Visually distinct and clear ---
        Card(
          margin: const EdgeInsets.all(16.0),
          elevation: 4, // Adds a shadow
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12.0)), // Rounded corners
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start, // Aligns content to the start
              children: [
                Text(
                  'Add New Task',
                  style: Theme.of(context).textTheme.headlineSmall?.copyWith(fontWeight: FontWeight.bold),
                ),
                const SizedBox(height: 15),
                TextField(
                  controller: _taskController,
                  decoration: InputDecoration(
                    labelText: 'Task Title',
                    hintText: 'e.g., Study Flutter, Call Mom',
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(8.0),
                    ),
                    prefixIcon: const Icon(Icons.edit_note), // Icon for task title input
                  ),
                  onSubmitted: (_) => _addTask(), // Add task when user presses Enter
                ),
                const SizedBox(height: 10), // Space between inputs

                Row(
                  children: [
                    Expanded(
                      child: GestureDetector(
                        onTap: () => _selectDate(context), // Opens date picker on tap
                        child: AbsorbPointer( // Prevents keyboard from appearing on tap
                          child: TextField(
                            controller: TextEditingController(
                              text: _selectedDate?.formattedDate ?? 'Select Date', // Displays selected date
                            ),
                            decoration: InputDecoration(
                              labelText: 'Date',
                              border: OutlineInputBorder(borderRadius: BorderRadius.circular(8.0)),
                              prefixIcon: const Icon(Icons.calendar_today),
                              suffixIcon: _selectedDate != null ? IconButton( // Clear button if date is selected
                                icon: const Icon(Icons.clear, size: 20),
                                onPressed: () {
                                  setState(() {
                                    _selectedDate = null; // Clear selected date
                                  });
                                },
                              ) : null,
                            ),
                          ),
                        ),
                      ),
                    ),
                    const SizedBox(width: 10),
                    Expanded(
                      child: GestureDetector(
                        onTap: () => _selectTime(context), // Opens time picker on tap
                        child: AbsorbPointer( // Prevents keyboard from appearing on tap
                          child: TextField(
                            controller: TextEditingController(
                              text: _selectedTime?.formattedTime ?? 'Select Time', // Displays selected time
                            ),
                            decoration: InputDecoration(
                              labelText: 'Time',
                              border: OutlineInputBorder(borderRadius: BorderRadius.circular(8.0)),
                              prefixIcon: const Icon(Icons.access_time),
                              suffixIcon: _selectedTime != null ? IconButton( // Clear button if time is selected
                                icon: const Icon(Icons.clear, size: 20),
                                onPressed: () {
                                  setState(() {
                                    _selectedTime = null; // Clear selected time
                                  });
                                },
                              ) : null,
                            ),
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 15),
                SizedBox( // Makes the button fill the width
                  width: double.infinity,
                  child: ElevatedButton.icon( // Button with an icon and label
                    onPressed: _addTask,
                    style: ElevatedButton.styleFrom(
                      padding: const EdgeInsets.symmetric(vertical: 15),
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(8.0),
                      ),
                    ),
                    icon: const Icon(Icons.add), // Add icon
                    label: const Text('Add Task'), // Button text
                  ),
                ),
              ],
            ),
          ),
        ),

        // --- Task List Section ---
        Expanded(
          child: _tasks.isEmpty
              ? const Center( // Displayed when no tasks are present
                  child: Text(
                    'No tasks yet! Add one above.',
                    style: TextStyle(fontSize: 18, color: Colors.grey),
                  ),
                )
              : ListView.builder( // Efficiently builds a scrollable list of tasks
                  itemCount: _tasks.length,
                  itemBuilder: (context, index) {
                    final task = _tasks[index]; // Get the current Task object
                    return Card(
                      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                      elevation: 2,
                      // Apply different background color if task is completed
                      color: task.isCompleted ? Colors.green[50] : null,
                      child: ListTile(
                        // Checkbox for marking task as complete/incomplete
                        leading: Checkbox(
                          value: task.isCompleted,
                          onChanged: (bool? value) {
                            _toggleTaskCompletion(index, value); // Toggle completion
                          },
                          activeColor: Theme.of(context).primaryColor, // Color when checked
                        ),
                        title: Text(
                          task.title,
                          style: TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.w500,
                            // Apply strikethrough if completed
                            decoration: task.isCompleted ? TextDecoration.lineThrough : TextDecoration.none,
                            color: task.isCompleted ? Colors.grey[600] : Colors.black, // Dim color if completed
                          ),
                        ),
                        subtitle: Text(
                          '${task.formattedDate} ${task.formattedTime}', // Display formatted date and time
                          style: TextStyle(
                            fontSize: 14,
                            color: task.isCompleted ? Colors.grey[500] : Colors.grey[700],
                            decoration: task.isCompleted ? TextDecoration.lineThrough : TextDecoration.none,
                          ),
                        ),
                        // Button to delete a task
                        trailing: IconButton(
                          icon: const Icon(Icons.delete_outline, color: Colors.redAccent),
                          onPressed: () => _removeTask(index), // Remove task
                        ),
                        onTap: () {
                          // Tapping the list item itself also toggles completion for quick interaction
                          _toggleTaskCompletion(index, !task.isCompleted);
                        },
                      ),
                    );
                  },
                ),
        ),
      ],
    );
  }

  @override
  void dispose() {
    _taskController.dispose(); // Clean up the text editing controller
    super.dispose();
  }
}